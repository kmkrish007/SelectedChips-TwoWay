/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "_content/Syncfusion.Blazor/scripts/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./bundles/sf-diagramcomponent.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./bundles/sf-diagramcomponent.js":
/*!****************************************!*\
  !*** ./bundles/sf-diagramcomponent.js ***!
  \****************************************/
/*! no exports provided */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_sf_diagramcomponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/sf-diagramcomponent.js */ "./modules/sf-diagramcomponent.js");
/* harmony import */ var _modules_sf_diagramcomponent_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_modules_sf_diagramcomponent_js__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "./modules/sf-diagramcomponent.js":
/*!****************************************!*\
  !*** ./modules/sf-diagramcomponent.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

window.sfBlazor = window.sfBlazor || {};

window.sfBlazor.Diagram = function () {
  'use strict';
  /**
   * Rect defines and processes rectangular regions
   */

  var Rect =
  /** @class */
  function () {
    function Rect(x, y, width, height) {
      /**
       * Sets the x-coordinate of the starting point of a rectangular region
       *
       * @default 0
       */
      this.x = Number.MAX_VALUE;
      /**
       * Sets the y-coordinate of the starting point of a rectangular region
       *
       * @default 0
       */

      this.y = Number.MAX_VALUE;
      /**
       * Sets the width of a rectangular region
       *
       * @default 0
       */

      this.width = 0;
      /**
       * Sets the height of a rectangular region
       *
       * @default 0
       */

      this.height = 0;

      if (x === undefined || y === undefined) {
        x = y = Number.MAX_VALUE;
        width = height = 0;
      } else {
        if (width === undefined) {
          width = 0;
        }

        if (height === undefined) {
          height = 0;
        }
      }

      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
    }
    /**   @private  */


    Rect.empty = new Rect(Number.MAX_VALUE, Number.MIN_VALUE, 0, 0);
    return Rect;
  }();
  /** @private */


  function applyStyleAgainstCsp(svg, attributes) {
    var keys = attributes.split(';');

    for (var i = 0; i < keys.length; i++) {
      var attribute = keys[i].split(':');

      if (attribute.length === 2) {
        svg.style[attribute[0].trim()] = attribute[1].trim();
      }
    }
  }
  /** @private */


  function setAttributeHtml(element, attributes) {
    var keys = Object.keys(attributes);

    for (var i = 0; i < keys.length; i++) {
      if (keys[i] !== 'style') {
        element.setAttribute(keys[i], attributes[keys[i]]);
      } else {
        applyStyleAgainstCsp(element, attributes[keys[i]]);
      }
    }
  }
  /** @hidden */


  function parentsUntil(elem, selector, isID) {
    var parent = elem;

    while (parent) {
      if (isID ? parent.id === selector : hasClass(parent, selector)) {
        break;
      }

      parent = parent.parentNode;
    }

    return parent;
  }
  /** @hidden */


  function hasClass(element, className) {
    var eClassName = _typeof(element.className) === 'object' ? element.className.animVal : element.className;
    return (' ' + eClassName + ' ').indexOf(' ' + className + ' ') > -1 ? true : false;
  }
  /**
   * Init Draggable
   */


  var InitDraggable =
  /** @class */
  function () {
    function InitDraggable(parent, symbolPaletteInstance) {
      var _this = this;

      this.over = function (e) {
        var previewElementValue = "clonedNode";
        var symbolPaletteDragEnter = "SymbolPaletteDragEnter";
        var previewElement = document.getElementById(previewElementValue);
        var component;

        for (var i = _this.symbolPaletteInstance.length - 1; i >= 0; i--) {
          if (e.dragData.draggable.id === _this.symbolPaletteInstance[i].id) {
            component = _this.symbolPaletteInstance[i].componentInstance;
            break;
          }
        }

        component.invokeMethodAsync(symbolPaletteDragEnter, e.target.id.split("_")[0]);

        if (previewElement) {
          sf.base.remove(previewElement);
          var cloneNode = document.getElementsByClassName("e-cloneproperties e-draganddrop e-dragclone");
          cloneNode[0].style.width = "1px";
          cloneNode[0].style.height = "1px";
        }
      };

      this.drop = function (e) {
        var component;
        var symbolPaletteDrop = "SymbolPaletteDrop";
        var diagramClass = "e-diagram";

        for (var i = _this.symbolPaletteInstance.length - 1; i >= 0; i--) {
          if (e.dragData.draggable.id === _this.symbolPaletteInstance[i].id) {
            component = _this.symbolPaletteInstance[i].componentInstance;
            break;
          }
        }

        var ParentElement = parentsUntil(e.target, diagramClass);
        component.invokeMethodAsync(symbolPaletteDrop, ParentElement.id);
        sf.base.remove(e.droppedElement);
      };

      this.out = function (e) {
        var component;
        var symbolPaletteDragLeave = "SymbolPaletteDragLeave";

        for (var i = _this.symbolPaletteInstance.length - 1; i >= 0; i--) {
          if (e.target.children[0].id === _this.symbolPaletteInstance[i].id || e.target.parentNode.parentNode.parentElement.id === _this.symbolPaletteInstance[i].id) {
            component = _this.symbolPaletteInstance[i].componentInstance;
            break;
          }
        }

        if (component) {
          component.invokeMethodAsync(symbolPaletteDragLeave);
        }
      };

      this.helper = function (e) {
        var previewID = "previewID";
        var accordianControl = "e-control e-accordion";
        var helperElement = "helperElement";
        var PaletteControl = document.getElementsByClassName(accordianControl)[0];
        var visualElement = sf.base.createElement('div', {
          className: 'e-cloneproperties e-draganddrop e-dragclone',
          styles: 'color:"transparent" height:"auto",  width:' + PaletteControl.offsetWidth
        });
        var previewElement = document.getElementById(previewID);

        if (previewElement === null) {
          previewElement = e.sender.target;
        }

        if (previewElement) {
          visualElement.setAttribute("id", helperElement);
          document.body.appendChild(visualElement);
          return visualElement;
        }

        return null;
      };

      this.dragStart = function (e) {
        e.bindEvents(e.dragElement);
      };

      this.drag = function (e) {
        var diagramClass = "e-diagram";

        if (!parentsUntil(e.target, diagramClass)) {
          var helperElement = "helperElement";
          var previewID = "previewID";
          var previewElement = document.getElementById(previewID);
          var canAllowDrag = void 0;

          for (var i = _this.symbolPaletteInstance.length - 1; i >= 0; i--) {
            if (e.element.id === _this.symbolPaletteInstance[i].id) {
              canAllowDrag = _this.symbolPaletteInstance[i].allowDrag;
              break;
            }
          }

          if (previewElement) {
            previewElement.style.visibility = "";
            var cloneNode = previewElement.cloneNode(true);
            cloneNode.style.display = "Block";
            cloneNode.style.visibility = true;
            cloneNode.setAttribute("class", "e-cloneproperties e-draganddrop e-dragclone");
            cloneNode.setAttribute("id", "clonedNode");
            var dragHelperElement = document.getElementById(helperElement);

            if (dragHelperElement && dragHelperElement.children[0]) {
              dragHelperElement.removeChild(dragHelperElement.children[0]);
            }

            if (!canAllowDrag) {
              dragHelperElement.style.opacity = "0";
            }

            dragHelperElement.appendChild(cloneNode);
          }
        }
      };

      this.dragStop = function (e) {
        var diagramClass = "e-diagram";
        var helperNode = document.getElementsByClassName("e-cloneproperties e-draganddrop e-dragclone");

        if (helperNode.length > 0) {
          helperNode[0].style.width = "1px";
          helperNode[0].style.height = "1px";
        }

        if (helperNode.length > 1) {
          for (var k = helperNode.length - 1; k > 0; k--) {
            if (helperNode[k].id == "helperElement") helperNode[k].remove();
          }
        }

        if (!parentsUntil(e.target, diagramClass)) {
          var helperElements = "helperElement";
          var helperElement = document.getElementById(helperElements);
          if (helperElement) helperElement.remove();
          var component = void 0;
          var elementDropToOutSideDiagram = "ElementDropToOutSideDiagram";

          for (var i = _this.symbolPaletteInstance.length - 1; i >= 0; i--) {
            if (e.element.id === _this.symbolPaletteInstance[i].id) {
              component = _this.symbolPaletteInstance[i].componentInstance;
              break;
            }
          }

          if (component) {
            component.invokeMethodAsync(elementDropToOutSideDiagram);
          }
        }
      };

      this.symbolPaletteInstance = symbolPaletteInstance;

      if (parent) {
        this.initializeDrag(parent);
      }
    }

    InitDraggable.prototype.initializeDrag = function (parent) {
      var element = parent.children[0];
      this.draggable = new sf.base.Draggable(element, {
        dragTarget: '.e-symbol-draggable',
        helper: this.helper,
        dragStart: this.dragStart,
        drag: this.drag,
        dragStop: this.dragStop,
        preventDefault: false
      });
      var droppableElements = document.getElementsByClassName("e-control e-diagram e-lib e-droppable e-tooltip");

      for (var i_1 = 0; i_1 < droppableElements.length; i_1++) {
        this.droppable = new sf.base.Droppable(droppableElements[i_1], {
          accept: '.e-dragclone',
          drop: this.drop,
          over: this.over,
          out: this.out
        });
      }

      var headerContent = document.getElementsByClassName("e-acrdn-header-content");

      for (var i = 0; i < headerContent.length; i++) {
        headerContent[i].style.textDecoration = "inherit";
      }
    };
    /**
     * To destroy the drag
     * @return {void}
     * @hidden
     */


    InitDraggable.prototype.destroy = function () {
      this.draggable.destroy();
    };

    return InitDraggable;
  }();

  var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : new P(function (resolve) {
          resolve(result.value);
        }).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator = undefined && undefined.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  var eventStarted = false;
  var inAction = false;
  var eventInvokeValue = 0;
  var isMouseWheel = false;
  var isZoomPan = false;
  var scrollDiagramID = "";
  var defaultTextStyle = {
    bold: false,
    italic: false,
    fontFamily: 'Arial',
    color: 'black',
    textAlign: "Center",
    fontSize: 12.0,
    textDecoration: "None",
    textOverflow: "Wrap",
    textWrapping: "WrapWithOverflow",
    whiteSpace: "CollapseSpace"
  };
  var diagram = {
    createHtmlElement: function createHtmlElement(elementType, attribute) {
      var element = sf.base.createElement(elementType);

      if (attribute) {
        this.setAttribute(element, attribute);
      }

      return element;
    },
    setAttribute: function setAttribute(element, attributes) {
      var keys = Object.keys(attributes);

      for (var i = 0; i < keys.length; i++) {
        element.setAttribute(keys[i], attributes[keys[i]]);
      }
    },
    createMeasureElements: function createMeasureElements(isZoomValue, layerList, width, height, elementId, component) {
      this.updateZoomPanTool(isZoomValue);
      this.updateInnerLayerSize(layerList, width, height);

      if (elementId && component) {
        this.onAddWireEvents(elementId, component);
      }

      var measureWindowElement = 'measureElement';

      if (!window[measureWindowElement]) {
        var divElement = this.createHtmlElement('div', {
          id: 'measureElement',
          style: 'visibility:hidden ; height: 0px ; width: 0px; overflow: hidden;'
        });
        var text = this.createHtmlElement('span', {
          'style': 'display:inline-block ; line-height: normal'
        });
        divElement.appendChild(text);
        var imageElement = void 0;
        imageElement = this.createHtmlElement('img', {});
        divElement.appendChild(imageElement);
        var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('xlink', 'http://www.w3.org/1999/xlink');
        divElement.appendChild(svg);
        var element = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        svg.appendChild(element);
        var tSpan = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');
        svg.appendChild(tSpan);
        window[measureWindowElement] = divElement;
        window[measureWindowElement].usageCount = 1;
        document.body.appendChild(divElement);
        var measureElementCount = 'measureElementCount';

        if (!window[measureElementCount]) {
          window[measureElementCount] = 1;
        } else {
          window[measureElementCount]++;
        }
      } else {
        window[measureWindowElement].usageCount += 1;
      }
    },
    updateZoomPanTool: function updateZoomPanTool(val) {
      isZoomPan = val;
    },
    updateInnerLayerSize: function updateInnerLayerSize(layerList, width, height, left, top, eventValue) {
      if (layerList != undefined && width != undefined && height != undefined && layerList.length > 0) {
        var layer = void 0;

        for (var i = 0; i < layerList.length - 1; i++) {
          layer = document.getElementById(layerList[i]);

          if (layer) {
            layer.style.width = width;
            layer.style.height = height;
          }
        }
      }

      if (isMouseWheel) {
        isMouseWheel = false;
      }

      if (layerList != undefined && layerList.length > 0) {
        var element = document.getElementById(layerList[layerList.length - 1]);
        return this.onChangeScrollValues(element, left, top, eventValue);
      }

      return null;
    },
    onChangeScrollValues: function onChangeScrollValues(element, left, top, eventValue) {
      if (element && left && top) {
        if (eventInvokeValue == eventValue) {
          eventStarted = false;
        }

        element.scrollLeft = left;
        element.scrollTop = top;
        return this.measureScrollValues(scrollDiagramID);
      }

      return null;
    },
    measureScrollValues: function measureScrollValues(diagramId) {
      var element = document.getElementById(diagramId);
      var point = new Rect(element.scrollLeft, element.scrollTop, element.scrollWidth, element.scrollHeight);
      return point;
    },
    measurePath: function measurePath(data) {
      if (data) {
        var measureWindowElement = 'measureElement';
        window[measureWindowElement].style.visibility = 'visible';
        var svg = window[measureWindowElement].children[2];
        var element = this.getChildNode(svg)[0];
        element.setAttribute('d', data);
        var bounds = element.getBBox();
        var svgBounds = new Rect(bounds.x, bounds.y, bounds.width, bounds.height);
        window[measureWindowElement].style.visibility = 'hidden';
        return svgBounds;
      }

      return new Rect(0, 0, 0, 0);
    },
    openUrl: function openUrl(url) {
      return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
          window.open(url, '_blank');
          return [2
          /*return*/
          ];
        });
      });
    },
    textEdit: function textEdit(annotation, centerPoint, nodeBounds, transform, canZoomTextEdit, annottaionId) {
      var _this = this;

      var textBoxDiv = "diagram_editTextBoxDiv";
      var editBoxDiv = "diagram_editBox";
      var textEditing = document.getElementById(textBoxDiv);
      var x;
      var y;
      annotation.id = annottaionId;
      var attributes;
      var textArea = document.getElementById(editBoxDiv);
      var text = annotation.content;

      if (!textEditing && !textArea) {
        textEditing = this.createHtmlElement('div', {});
        textArea = this.createHtmlElement('textarea', {});
        var diagramDiv = document.getElementsByClassName("e-control e-diagram e-lib e-droppable e-tooltip");
        var diagramCanvas = diagramDiv[0].children[0];
        diagramCanvas.appendChild(textEditing);
        textEditing.appendChild(textArea);
        textArea.appendChild(document.createTextNode(text));
        this[textBoxDiv] = textEditing;
        this[editBoxDiv] = textArea;
      }

      var minWidth = 90;
      var maxWidth = annotation.bounds.width < nodeBounds.width ? annotation.bounds.width : nodeBounds.width;
      maxWidth = minWidth > maxWidth ? minWidth : maxWidth;
      var bounds = this.measureHtmlText(annotation.style, text, undefined, undefined, maxWidth);

      if (bounds.width == 0 && bounds.height == 0) {
        bounds.width = 50;
        bounds.height = 12;
      }

      var scale = canZoomTextEdit ? transform.scale : 1;
      bounds.width = Math.max(bounds.width, 50);
      x = (centerPoint.x + transform.tx) * transform.scale - bounds.width / 2 * scale - 2.5;
      y = (centerPoint.y + transform.ty) * transform.scale - bounds.height / 2 * scale - 3;
      attributes = {
        'id': 'diagram' + '_editTextBoxDiv',
        'style': 'position: absolute' + ';left:' + x + 'px;top:' + y + 'px;width:' + (bounds.width + 1) * scale + 'px;height:' + bounds.height * scale + 'px; containerName:' + 'temp' + ';'
      };
      setAttributeHtml(textEditing, attributes);
      var style = annotation.style;
      attributes = {
        'id': 'diagram' + '_editBox',
        'style': 'width:' + (bounds.width + 1) * scale + 'px;height:' + bounds.height * scale + 'px;resize: none;outline: none;overflow: hidden;' + ';font-family:' + style.fontFamily + ';font-size:' + style.fontSize * scale + 'px;text-align:' + annotation.style.textAlign.toLocaleLowerCase() + ';',
        'class': 'e-diagram-text-edit'
      };
      setAttributeHtml(textArea, attributes);
      textArea.style.fontWeight = style.bold ? 'bold' : '';
      textArea.style.fontStyle = style.italic ? 'italic' : '';
      textArea.style.lineHeight = (style.fontSize * 1.2 + 'px;').toString();
      var nodeTextbox = document.getElementById(annotation.id + "_text");

      if (nodeTextbox) {
        nodeTextbox.setAttribute("visibility", "hidden");
      }

      textArea.style.textDecoration = style.textDecoration ? style.textDecoration : '';
      textArea.addEventListener('input', function (e) {
        _this.inputChange(e, annotation, nodeBounds, centerPoint, transform, canZoomTextEdit);
      });
      textArea.select();
      window['annotation'] = annotation;
    },
    inputChange: function inputChange(e, annotation, nodeBounds, centerPoint, transform, canZoomTextEdit) {
      var minWidth = 90;
      var textBoxDiv = "diagram_editTextBoxDiv";
      var editBoxDiv = "diagram_editBox";
      var maxWidth;
      var minHeight = 12;
      var fontsize;
      var height;
      var width;
      var textBounds;
      var editTextBox = this[editBoxDiv];
      var editTextBoxDiv = this[textBoxDiv];
      var text = editTextBox.value;
      var line = text.split('\n');
      maxWidth = nodeBounds.width < annotation.bounds.width ? nodeBounds.width : annotation.bounds.width;
      maxWidth = maxWidth > minWidth ? maxWidth : minWidth;
      textBounds = this.measureHtmlText(annotation.style, text, undefined, undefined, maxWidth);
      fontsize = Number(editTextBox.style.fontSize.split('px')[0]);

      if (line.length > 1 && line[line.length - 1] === '') {
        textBounds.height = textBounds.height + fontsize;
      }

      var scale = canZoomTextEdit ? transform.scale : 1;
      width = textBounds.width;
      width = (minWidth > width ? minWidth : width) * scale;
      height = (minHeight > textBounds.height ? minHeight : textBounds.height) * scale;
      editTextBoxDiv.style.left = (centerPoint.x + transform.tx) * transform.scale - width / 2 - 2.5 + 'px';
      editTextBoxDiv.style.top = (centerPoint.y + transform.ty) * transform.scale - height / 2 - 3 + 'px';
      editTextBoxDiv.style.width = width + 'px';
      editTextBoxDiv.style.height = height + 'px';
      editTextBox.style.minHeight = minHeight + 'px';
      editTextBox.style.minWidth = minWidth + 'px';
      editTextBox.style.width = width + 'px';
      editTextBox.style.height = height + 'px';
    },
    measureHtmlText: function measureHtmlText(style, content, width, height, maxWidth) {
      var bounds = {};
      var text = this.createHtmlElement('span', {
        'style': 'display:inline-block; line-height: normal'
      });

      if (style.bold) {
        text.style.fontWeight = 'bold';
      }

      if (style.italic) {
        text.style.fontStyle = 'italic';
      }

      if (width !== undefined) {
        text.style.width = width.toString() + 'px';
      }

      if (height !== undefined) {
        text.style.height = height.toString() + 'px';
      }

      if (maxWidth !== undefined) {
        text.style.maxWidth = maxWidth.toString() + 'px';
      }

      text.style.fontFamily = style.fontFamily;
      text.style.fontSize = style.fontSize + 'px';
      text.style.color = style.color;
      text.textContent = content;
      text.style.whiteSpace = this.whiteSpaceToString(style.whiteSpace, style.textWrapping);

      if (maxWidth !== undefined) {
        text.style.wordBreak = 'break-word';
      } else {
        text.style.wordBreak = this.wordBreakToString(style.textWrapping);
      }

      document.body.appendChild(text);
      bounds.width = text.offsetWidth;
      bounds.height = text.offsetHeight;
      document.body.removeChild(text);
      return bounds;
    },
    getChildNode: function getChildNode(node) {
      var child;
      var collection = [];

      if (sf.base.Browser.info.name === 'msie' || sf.base.Browser.info.name === 'edge') {
        for (var i = 0; i < node.childNodes.length; i++) {
          child = node.childNodes[i];

          if (child.nodeType === 1) {
            collection.push(child);
          }
        }
      } else {
        collection = node.children;
      }

      return collection;
    },
    measureBounds: function measureBounds(pathobj, textObj, imageObj, nativeObj) {
      return __awaiter(this, void 0, void 0, function () {
        var previousValue, accordianPanel, k, finalResult, pathResult, textResult, imageResult, nativeResult, measureWindowElement, result, svg, element, i, data, bounds, svgBounds, dom, bounds, result, i, data, content, style, size, nodeSz, images, value, result, result, results, nativeSize, i, nativeId, nativeBounds, svgBounds, k;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              if (nativeObj != null) {
                accordianPanel = document.getElementsByClassName("e-acrdn-panel e-content-hide");
                previousValue = [];

                for (k = 0; k < accordianPanel.length; k++) {
                  previousValue[k] = accordianPanel[k].style.display;
                  accordianPanel[k].style.display = "block";
                }
              }

              finalResult = {};
              pathResult = {};
              textResult = {};
              imageResult = {};
              nativeResult = {};
              measureWindowElement = 'measureElement';

              if (pathobj) {
                result = Object.keys(pathobj).map(function (key) {
                  return [pathobj[key], key];
                });
                window[measureWindowElement].style.visibility = 'visible';
                svg = window[measureWindowElement].children[2];
                element = this.getChildNode(svg)[0];

                for (i = 0; i < result.length; i++) {
                  if (result[i][0] == "Path") {
                    data = result[i][1];
                    element.setAttribute('d', data);
                    bounds = element.getBBox();
                    svgBounds = {
                      x: bounds.x,
                      y: bounds.y,
                      width: bounds.width,
                      height: bounds.height
                    };
                    pathResult[data] = svgBounds;
                  } else if (result[i][0].indexOf("GetBoundingClientRect") != -1) {
                    dom = document.getElementById(result[i][1]);

                    if (dom) {
                      bounds = dom.getBoundingClientRect();
                      pathResult[result[i][0]] = {
                        x: bounds.x,
                        y: bounds.y,
                        width: bounds.width,
                        height: bounds.height
                      };
                    }

                    if (result[i][0] == "GetBoundingClientRect") {
                      scrollDiagramID = result[i][1];
                      pathResult["GetScrollerBounds"] = this.measureScrollValues(result[i][1]);
                    }
                  }
                }
              }

              if (textObj) {
                result = Object.keys(textObj).map(function (key) {
                  return [textObj[key], key];
                });

                for (i = 0; i < result.length; i++) {
                  data = result[i][1];
                  content = textObj[data].content;
                  style = textObj[data].style;
                  size = textObj[data].bounds;
                  nodeSz = textObj[data].nodeSize;
                  size.width = size.width == null ? undefined : size.width;
                  size.height = size.height == null ? undefined : size.height;
                  nodeSz.width = nodeSz.width == null ? undefined : nodeSz.width;
                  nodeSz.height = nodeSz.height == null ? undefined : nodeSz.height;
                  textResult[data] = this.measureText(size, style, content, size.width || nodeSz.width);
                }
              }

              if (!imageObj) return [3
              /*break*/
              , 2];
              images = Object.keys(imageObj).map(function (key) {
                return [imageObj[key], key];
              });
              if (!(images.length > 0)) return [3
              /*break*/
              , 2];
              value = 0;
              result = {};
              return [4
              /*yield*/
              , this.loadImage(images, value, result)];

            case 1:
              _a.sent();

              imageResult = result;
              _a.label = 2;

            case 2:
              if (nativeObj) {
                result = Object.keys(nativeObj).map(function (key) {
                  return [nativeObj[key], key];
                });

                if (result.length > 0) {
                  results = {};
                  nativeSize = {};

                  for (i = 0; i < result.length; i++) {
                    nativeId = result[i][0];
                    nativeBounds = document.getElementById(nativeId);
                    svgBounds = nativeBounds.getBoundingClientRect();
                    nativeSize = {
                      width: svgBounds.width,
                      height: svgBounds.height
                    };
                    results[result[i][1]] = nativeSize;
                  }

                  nativeResult = results;
                }
              }

              pathResult["GetScrollerWidth"] = this.getScrollerWidth();
              finalResult["Path"] = pathResult;
              finalResult["Text"] = textResult;
              finalResult["Image"] = imageResult;
              finalResult["Native"] = nativeResult;

              if (previousValue != null) {
                for (k = 0; k < accordianPanel.length; k++) {
                  accordianPanel[k].style.display = previousValue[k].toString();
                }
              }

              window[measureWindowElement].style.visibility = 'hidden';
              return [2
              /*return*/
              , finalResult];
          }
        });
      });
    },
    measureText: function measureText(size, style, content, maxWidth, textValue) {
      var finalResult = {};
      var bounds = {
        width: 0,
        height: 0
      };
      var childNodes;
      var wrapBounds;
      var options = this.getTextOptions(content, size, style, maxWidth);
      childNodes = this.wrapSvgText(options, textValue, maxWidth);
      wrapBounds = this.wrapSvgTextAlign(options, childNodes);
      bounds.width = wrapBounds.width;

      if (wrapBounds.width >= maxWidth && options.textOverflow !== 'Wrap') {
        bounds.width = maxWidth;
      }

      bounds.height = childNodes.length * options.fontSize * 1.2;

      if (wrapBounds.width > options.width && options.textOverflow !== 'Wrap' && options.textWrapping === 'NoWrap') {
        childNodes[0].text = this.overFlow(options.content, options);
      }

      finalResult["Bounds"] = bounds;
      finalResult["WrapBounds"] = wrapBounds;
      finalResult["ChildNodes"] = childNodes;
      return finalResult;
    },
    getTextOptions: function getTextOptions(content, size, style, maxWidth) {
      var options = {
        fill: style.fill,
        stroke: style.strokeColor,
        strokeWidth: style.strokeWidth,
        dashArray: style.strokeDashArray,
        opacity: style.opacity,
        gradient: style.gradient,
        width: maxWidth || size.width,
        height: size.height
      };
      options.fontSize = style.fontSize || defaultTextStyle.fontSize;
      options.fontFamily = style.fontFamily || defaultTextStyle.fontFamily;
      options.textOverflow = style.textOverflow || defaultTextStyle.textOverflow;
      options.textDecoration = style.textDecoration || defaultTextStyle.textDecoration;
      options.doWrap = style.doWrap;
      options.whiteSpace = this.whiteSpaceToString(style.whiteSpace || defaultTextStyle.whiteSpace, style.textWrapping || defaultTextStyle.textWrapping);
      options.content = content;
      options.textWrapping = style.textWrapping || defaultTextStyle.textWrapping;
      options.breakWord = this.wordBreakToString(style.textWrapping || defaultTextStyle.textWrapping);
      options.textAlign = this.textAlignToString(style.textAlign || defaultTextStyle.textAlign);
      options.color = style.color || defaultTextStyle.color;
      options.italic = style.italic || defaultTextStyle.italic;
      options.bold = style.bold || defaultTextStyle.bold;
      options.dashArray = '';
      options.strokeWidth = 0;
      options.fill = '';
      return options;
    },
    whiteSpaceToString: function whiteSpaceToString(value, wrap) {
      if (wrap === 'NoWrap' && value === 'PreserveAll') {
        return 'pre';
      }

      var state = '';

      switch (value) {
        case 'CollapseAll':
          state = 'nowrap';
          break;

        case 'CollapseSpace':
          state = 'pre-line';
          break;

        case 'PreserveAll':
          state = 'pre-wrap';
          break;
      }

      return state;
    },
    wordBreakToString: function wordBreakToString(value) {
      var state = '';

      switch (value) {
        case 'Wrap':
          state = 'breakall';
          break;

        case 'NoWrap':
          state = 'keepall';
          break;

        case 'WrapWithOverflow':
          state = 'normal';
          break;

        case 'LineThrough':
          state = 'line-through';
          break;
      }

      return state;
    },
    textAlignToString: function textAlignToString(value) {
      var state = '';

      switch (value) {
        case 'Center':
          state = 'center';
          break;

        case 'Left':
          state = 'left';
          break;

        case 'Right':
          state = 'right';
          break;
      }

      return state;
    },
    wrapSvgText: function wrapSvgText(text, textValue, laneWidth) {
      var childNodes = [];
      var k = 0;
      var txtValue;
      var bounds1;
      var content = textValue || text.content;

      if (text.whiteSpace !== 'nowrap' && text.whiteSpace !== 'pre') {
        if (text.breakWord === 'breakall') {
          txtValue = '';
          txtValue += content[0];

          for (k = 0; k < content.length; k++) {
            bounds1 = this.bBoxText(txtValue, text);

            if (bounds1 >= text.width && txtValue.length > 0) {
              childNodes[childNodes.length] = {
                text: txtValue,
                x: 0,
                dy: 0,
                width: bounds1
              };
              txtValue = '';
            } else {
              txtValue = txtValue + (content[k + 1] || '');

              if (txtValue.indexOf('\n') > -1) {
                childNodes[childNodes.length] = {
                  text: txtValue,
                  x: 0,
                  dy: 0,
                  width: this.bBoxText(txtValue, text)
                };
                txtValue = '';
              }

              var width = this.bBoxText(txtValue, text);

              if (Math.ceil(width) + 2 >= text.width && txtValue.length > 0) {
                childNodes[childNodes.length] = {
                  text: txtValue,
                  x: 0,
                  dy: 0,
                  width: width
                };
                txtValue = '';
              }

              if (k === content.length - 1 && txtValue.length > 0) {
                childNodes[childNodes.length] = {
                  text: txtValue,
                  x: 0,
                  dy: 0,
                  width: width
                };
                txtValue = '';
              }
            }
          }
        } else {
          childNodes = this.wordWrapping(text, textValue, laneWidth);
        }
      } else {
        childNodes[childNodes.length] = {
          text: content,
          x: 0,
          dy: 0,
          width: this.bBoxText(content, text)
        };
      }

      return childNodes;
    },
    wordWrapping: function wordWrapping(text, textValue, laneWidth) {
      var childNodes = [];
      var txtValue = '';
      var j = 0;
      var i = 0;
      var wrap = text.whiteSpace !== 'nowrap' ? true : false;
      var content = textValue || text.content;
      var eachLine = content.split('\n');
      var words;
      var newText;
      var existingWidth;
      var existingText;

      for (j = 0; j < eachLine.length; j++) {
        words = text.textWrapping !== 'NoWrap' ? eachLine[j].split(' ') : text.textWrapping === 'NoWrap' ? [eachLine[j]] : eachLine;

        for (i = 0; i < words.length; i++) {
          txtValue += ((i !== 0 || words.length === 1) && wrap && txtValue.length > 0 ? ' ' : '') + words[i];
          newText = txtValue + ' ' + (words[i + 1] || '');
          var width = this.bBoxText(newText, text);

          if (Math.floor(width) > (laneWidth || text.width) - 2 && txtValue.length > 0) {
            childNodes[childNodes.length] = {
              text: txtValue,
              x: 0,
              dy: 0,
              width: newText === txtValue ? width : txtValue === existingText ? existingWidth : this.bBoxText(txtValue, text)
            };
            txtValue = '';
          } else {
            if (i === words.length - 1) {
              childNodes[childNodes.length] = {
                text: txtValue,
                x: 0,
                dy: 0,
                width: width
              };
              txtValue = '';
            }
          }

          existingText = newText;
          existingWidth = width;
        }
      }

      return childNodes;
    },
    wrapSvgTextAlign: function wrapSvgTextAlign(text, childNodes) {
      var wrapBounds = {
        x: 0,
        width: 0
      };
      var k = 0;
      var txtWidth;
      var width;

      for (k = 0; k < childNodes.length; k++) {
        txtWidth = childNodes[k].width;
        width = txtWidth;

        if (text.textAlign === 'left') {
          txtWidth = 0;
        } else if (text.textAlign === 'center') {
          if (txtWidth > text.width && (text.textOverflow === 'Ellipsis' || text.textOverflow === 'Clip')) {
            txtWidth = 0;
          } else {
            txtWidth = -txtWidth / 2;
          }
        } else if (text.textAlign === 'right') {
          txtWidth = -txtWidth;
        } else {
          txtWidth = childNodes.length > 1 ? 0 : -txtWidth / 2;
        }

        childNodes[k].dy = text.fontSize * 1.2;
        childNodes[k].x = txtWidth;

        if (!wrapBounds) {
          wrapBounds = {
            x: txtWidth,
            width: width
          };
        } else {
          wrapBounds.x = Math.min(wrapBounds.x, txtWidth);
          wrapBounds.width = Math.max(wrapBounds.width, width);
        }
      }

      return wrapBounds;
    },
    overFlow: function overFlow(text, options) {
      var i = 0;
      var j = 0;
      var middle = 0;
      var bounds = 0;
      var temp = '';
      j = text.length;
      var t = 0;

      do {
        if (bounds > 0) {
          i = middle;
        }

        middle = Math.floor(this.middleElement(i, j));
        temp += text.substr(i, middle);
        bounds = this.bBoxText(temp, options);
      } while (bounds <= options.width);

      temp = temp.substr(0, i);

      for (t = i; t < j; t++) {
        temp += text[t];
        bounds = this.bBoxText(temp, options);

        if (bounds >= options.width) {
          text = text.substr(0, temp.length - 1);
          break;
        }
      }

      if (options.textOverflow === 'Ellipsis') {
        text = text.substr(0, text.length - 3);
        text += '...';
      } else {
        text = text.substr(0, text.length);
      }

      return text;
    },
    middleElement: function middleElement(i, j) {
      var m = 0;
      m = (i + j) / 2;
      return m;
    },
    getScrollerWidth: function getScrollerWidth() {
      var outer = this.createHtmlElement('div', {
        'style': 'visibility:hidden; width: 100px'
      });
      document.body.appendChild(outer);
      var widthNoScroll = outer.getBoundingClientRect().width;
      outer.style.overflow = 'scroll';
      var inner = this.createHtmlElement('div', {
        'style': 'width:100%'
      });
      outer.appendChild(inner);
      var widthWithScroll = inner.getBoundingClientRect().width;
      outer.parentNode.removeChild(outer);
      var svgBounds = {
        x: 0,
        y: 0,
        width: widthNoScroll - widthWithScroll,
        height: 0
      };
      return svgBounds;
    },
    pathPoints: function pathPoints(pathPointsObj) {
      return __awaiter(this, void 0, void 0, function () {
        var pathPoints, result, i, data;
        return __generator(this, function (_a) {
          pathPoints = {};

          if (pathPointsObj) {
            result = Object.keys(pathPointsObj).map(function (key) {
              return [pathPointsObj[key], key];
            });

            for (i = 0; i < result.length; i++) {
              if (result.length > 0) {
                data = result[i][1];
                pathPoints[result[i][0]] = this.findSegmentPoints(data);
              }
            }
          }

          return [2
          /*return*/
          , pathPoints];
        });
      });
    },
    findSegmentPoints: function findSegmentPoints(pathData) {
      var pts = [];
      var sample;
      var sampleLength;
      var measureWindowElement = 'measureElement';
      window[measureWindowElement].style.visibility = 'visible';
      var svg = window[measureWindowElement].children[2];
      var pathNode = this.getChildNode(svg)[0];
      pathNode.setAttributeNS(null, 'd', pathData);
      var pathLength = pathNode.getTotalLength();

      for (sampleLength = 0; sampleLength <= pathLength; sampleLength += 10) {
        sample = pathNode.getPointAtLength(sampleLength);
        pts.push({
          x: sample.x,
          y: sample.y
        });
      }

      window[measureWindowElement].style.visibility = 'hidden';
      return pts;
    },
    loadImage: function loadImage(images, value, result) {
      return __awaiter(this, void 0, void 0, function () {
        var promise, _a, _b;

        return __generator(this, function (_c) {
          switch (_c.label) {
            case 0:
              promise = new Promise(function (resolve, reject) {
                var imageSize = {};
                var measureWindowElement = 'measureElement';
                window[measureWindowElement].style.visibility = 'visible';
                var imageElement = window[measureWindowElement].children[1];
                imageElement.setAttribute('src', images[value][0]);
                window[measureWindowElement].style.visibility = 'hidden';
                var element = document.createElement('img');
                element.setAttribute('src', images[value][0]);
                setAttributeHtml(element, {
                  id: "imagesf" + value + "imageNode",
                  style: 'display: none;'
                });
                document.body.appendChild(element);

                element.onload = function (event) {
                  var loadedImage = event.currentTarget;
                  imageSize = {
                    width: loadedImage.width,
                    height: loadedImage.height
                  };
                  resolve(imageSize);
                };
              });
              _a = result;
              _b = images[value][1];
              return [4
              /*yield*/
              , promise];

            case 1:
              _a[_b] = _c.sent();
              if (!(value == images.length - 1)) return [3
              /*break*/
              , 2];
              return [2
              /*return*/
              , result];

            case 2:
              value++;
              return [4
              /*yield*/
              , this.loadImage(images, value, result)];

            case 3:
              _c.sent();

              _c.label = 4;

            case 4:
              return [2
              /*return*/
              ];
          }
        });
      });
    },
    bBoxText: function bBoxText(textContent, options) {
      var measureWindowElement = 'measureElement';
      window[measureWindowElement].style.visibility = 'visible';
      var svg = window[measureWindowElement].children[2];
      var text = this.getChildNode(svg)[1];
      text.textContent = textContent;
      applyStyleAgainstCsp(text, 'font-size:' + options.fontSize + 'px; font-family:' + options.fontFamily + ';font-weight:' + (options.bold ? 'bold' : 'normal'));
      var bBox = text.getBBox().width;
      window[measureWindowElement].style.visibility = 'hidden';
      return bBox;
    },
    endEdit: function endEdit(e) {
      setTimeout(function () {
        var nodeTextbox = document.getElementById(annotation.id + "_text");

        if (nodeTextbox) {
          nodeTextbox.setAttribute("visibility", "visible");
        }
      }, 100);
      var textBoxDiv = "diagram_editTextBoxDiv";
      var editBoxDiv = "diagram_editBox";
      var textArea = this[editBoxDiv];
      var annotation = window['annotation'];
      var content = window['isEscape'] ? annotation.content : textArea.value;
      var style = annotation.style;
      var size = annotation.bounds;
      var nodeSize = annotation.nodeSize;
      nodeSize.width = nodeSize.width == null ? undefined : nodeSize.width;
      nodeSize.height = nodeSize.height == null ? undefined : nodeSize.height;
      var annotationValue = {};
      var finalResult = {};
      annotationValue[annotation.id] = this.measureText(size, style, content, size.width || nodeSize.width);
      annotationValue[annotation.id].Content = content;
      finalResult["Text"] = annotationValue;
      var textBoxEditElement = this[textBoxDiv];
      textBoxEditElement.remove();
      return finalResult;
    },
    onAddWireEvents: function onAddWireEvents(id, component) {
      var _this = this;

      var element = document.getElementById(id);
      element.addEventListener('mousedown', function (e) {
        _this.invokeDiagramEvents(e, component);
      });
      element.addEventListener('mousemove', function (e) {
        _this.invokeDiagramEvents(e, component);
      });
      element.addEventListener('mouseup', function (e) {
        _this.invokeDiagramEvents(e, component);
      });
      element.addEventListener('mouseleave', function (e) {
        _this.invokeDiagramEvents(e, component);
      });
      element.addEventListener('scroll', function (e) {
        _this.invokeDiagramEvents(e, component);
      });
      element.addEventListener('mousewheel', function (e) {
        _this.invokeDiagramEvents(e, component);
      });
      element.addEventListener('keydown', function (e) {
        _this.invokeDiagramEvents(e, component);
      });
      element.addEventListener('keyup', function (e) {
        _this.invokeDiagramEvents(e, component);
      });
    },
    invokeDiagramEvents: function invokeDiagramEvents(e, component) {
      var finalResult;
      var textBoxDiv = "diagram_editTextBoxDiv";
      var editTextBoxDiv = this[textBoxDiv];
      var args = {};
      var action;

      if (e.type == "mousedown") {
        action = true;
      }

      if (e.type == "mouseup") {
        action = false;
      }

      if ((e.type == "mouseleave" || e.key == "Escape" || e.type == "mousedown" && e.target.id != "diagram_editBox") && editTextBoxDiv) {
        window['isEscape'] = e.key == "Escape" ? true : false;
        finalResult = this.endEdit(e, this);
        this[textBoxDiv] = editTextBoxDiv = document.getElementById("diagram_editTextBoxDiv");
      }

      args = this.getMouseEvents(e);

      if (e.key == "Escape") {
        var helperElements = "helperElement";
        var helperElement = document.getElementById(helperElements);

        if (helperElement) {
          sf.base.remove(helperElement);
          helperElement.remove();
        }
      }

      if (!editTextBoxDiv && (e.type == "mousemove" && !eventStarted || e.type != "mousemove" || !inAction)) {
        if (e.type == "mousemove" && action && isZoomPan) {
          eventStarted = true;
          args.eventInvokeValue = ++eventInvokeValue;
        }

        if (e.type == "keydown" || e.type == "keyup" || e.type != "scroll" || e.type == "scroll" && !isMouseWheel) {
          component.invokeMethodAsync('InvokeDiagramEvents', args, finalResult);
        }
      }

      if (e.type == "mouseup" || e.type == "mousemove" && !this[textBoxDiv]) {
        e.currentTarget.focus();
      }
    },
    isForeignObject: function isForeignObject(target, isTextBox) {
      var foreignobject = target;

      if (foreignobject) {
        while (foreignobject.parentNode !== null) {
          if (typeof foreignobject.className === 'string' && (!isTextBox && foreignobject.className.indexOf('foreign-object') !== -1 || isTextBox && foreignobject.className.indexOf('e-diagram-text-edit') !== -1)) {
            return foreignobject;
          } else {
            foreignobject = foreignobject.parentNode;
          }
        }
      }

      return null;
    },
    getMouseEvents: function getMouseEvents(evt) {
      var mouseEventArgs = {};
      mouseEventArgs = {
        altKey: evt.altKey,
        shiftKey: evt.shiftKey,
        ctrlKey: evt.ctrlKey,
        detail: evt.detail,
        metaKey: evt.metaKey,
        screenX: evt.screenX,
        screenY: evt.screenY,
        clientX: evt.clientX,
        clientY: evt.clientY,
        offsetX: evt.offsetX,
        offsetY: evt.offsetY,
        type: evt.type,
        key: evt.key,
        keyCode: evt.keyCode,
        button: evt.button
      };

      if (evt.currentTarget) {
        var bounds = this.measureScrollValues(evt.currentTarget.id);
        mouseEventArgs.diagramCanvasScrollBounds = bounds;
        mouseEventArgs.diagramGetBoundingClientRect = evt.currentTarget.getBoundingClientRect();
      } else if (evt.target) {
        var bounds = this.measureScrollValues(evt.target.id);
        mouseEventArgs.diagramCanvasScrollBounds = bounds;
        mouseEventArgs.diagramGetBoundingClientRect = evt.target.getBoundingClientRect();
      }

      if (evt.type == "mousewheel") {
        evt.preventDefault();
        evt.currentTarget.focus();
        mouseEventArgs.wheelDelta = evt.wheelDelta;
        isMouseWheel = true;
      }

      if (evt.type == "mousedown") {
        inAction = true;
      }

      if (evt.type == "mouseup") {
        inAction = false;
      }

      if (!this.isForeignObject(evt.target, true) && (evt.type == "mouseleave" || evt.type == "mousmove" || evt.type == "mousedown" || evt.type == "mouseup" || evt.type == "keydown" || evt.type == "keyup")) {
        evt.preventDefault();
      }

      return mouseEventArgs;
    },
    //Symbol palette Snippet Starts here 
    initialiseModule: function initialiseModule(element, component, allowDrag) {
      return __awaiter(this, void 0, void 0, function () {
        var symbolPaletteInstance, object, object;

        var _this = this;

        return __generator(this, function (_a) {
          symbolPaletteInstance = 'symbolPaletteInstance';

          if (window[symbolPaletteInstance]) {
            object = {
              id: element.children[0].id,
              componentInstance: component,
              allowDrag: allowDrag
            };
            window[symbolPaletteInstance].push(object);
          } else {
            object = {
              id: element.children[0].id,
              componentInstance: component,
              allowDrag: allowDrag
            };
            window[symbolPaletteInstance] = [];
            window[symbolPaletteInstance].push(object);
          }

          element.addEventListener('mousedown', function (e) {
            _this.invokePaletteEvents(e, component);
          });
          element.addEventListener('mousemove', function (e) {
            _this.invokePaletteEvents(e, component);
          });
          element.addEventListener('mouseup', function (e) {
            _this.invokePaletteEvents(e, component);
          });
          element.addEventListener('mouseleave', function (e) {
            _this.invokePaletteEvents(e, component);
          });
          setTimeout(function () {
            this.symbolPaletteDragAndDropModule = new InitDraggable(element, window[symbolPaletteInstance]);
          }, 100);
          return [2
          /*return*/
          ];
        });
      });
    },
    invokePaletteEvents: function invokePaletteEvents(e, component) {
      var invokePaletteEvents = "InvokePaletteEvents";
      var symbolDraggableClass = "e-symbol-draggable";
      var symbolhoverClass = "e-symbol-hover";
      var symbolId;
      e.preventDefault();
      var args = this.palettegetMouseEvents(e);

      if (e.target.id.split('_').length === 2) {
        symbolId = e.target.id.split('_')[0];
      }

      if (e.type == "mousemove" && !eventStarted || e.type != "mousemove" || !inAction) {
        if (e && e.target && e.type) {
          var element = document.getElementById(e.target.id);
          var container = void 0;

          if (element) {
            for (var k = 0; k < element.classList.length; k++) {
              if (element.classList[k] == symbolDraggableClass) {
                container = e.target;
                container.classList.add(symbolhoverClass);
                break;
              }
            }

            var hoverElementCount = document.getElementsByClassName(symbolhoverClass);

            if (hoverElementCount && hoverElementCount.length > 0) {
              for (var a = 0; a < hoverElementCount.length; a++) {
                var oldcontainer = hoverElementCount[a];

                if (container && container != oldcontainer || container == undefined) {
                  oldcontainer.classList.remove(symbolhoverClass);
                }
              }
            }
          }
        }

        component.invokeMethodAsync(invokePaletteEvents, args, symbolId);
      }
    },
    palettegetMouseEvents: function palettegetMouseEvents(evt) {
      var mouseEventArgs = {};
      mouseEventArgs = {
        altKey: evt.altKey,
        shiftKey: evt.shiftKey,
        ctrlKey: evt.ctrlKey,
        detail: evt.detail,
        metaKey: evt.metaKey,
        screenX: evt.screenX,
        screenY: evt.screenY,
        clientX: evt.clientX,
        clientY: evt.clientY,
        offsetX: evt.offsetX,
        offsetY: evt.offsetY,
        type: evt.type
      };
      return mouseEventArgs;
    }
  };
  return diagram;
}();

/***/ })

/******/ });