/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "_content/Syncfusion.Blazor/scripts/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./bundles/sf-toast.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./bundles/sf-toast.js":
/*!*****************************!*\
  !*** ./bundles/sf-toast.js ***!
  \*****************************/
/*! no exports provided */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_sf_toast_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/sf-toast.js */ "./modules/sf-toast.js");
/* harmony import */ var _modules_sf_toast_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_modules_sf_toast_js__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "./modules/sf-toast.js":
/*!*****************************!*\
  !*** ./modules/sf-toast.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

window.sfBlazor = window.sfBlazor || {};

window.sfBlazor.Toast = function () {
  'use strict';

  var CREATED_EVENT = 'CreatedEvent';
  var CLOSE_EVENT = 'CloseEvent';
  var OPEN_EVENT = 'OpenEvent';
  var ON_CLOSE_EVENT = 'OnCloseEvent';
  var DESTROY_TIMER = 'DestroyTimer';
  var MOUSEOVER_EVENT = 'MouseoverEvent';
  var CLOSEBTN = 'e-toast-close-icon';
  var ROOT = 'e-toast';
  var TOAST_BLAZOR_HIDDEN = 'e-blazor-toast-hidden';
  var PROGRESS = 'e-toast-progress';
  var HUN_PERCENT = '100%';
  var DEFAULT_WIDTH = '300px';
  var FULL_WIDTH = 'e-toast-full-width';
  var STRING = 'string';
  var RELATIVE = 'relative';
  var BODY = 'BODY';
  var RIGHT = 'Right';
  var LEFT = 'Left';
  var ELEMENT = 'element';
  var ALL = 'All';
  var ENTER_KEY = 13;
  var SPACE_KEY = 32;
  var TOAST_PRE = 'e-toast';
  var TOAST_CONTAINER = 'e-toast-container';
  var KEYDOWN = 'keydown';
  var FIXED = 'fixed';
  var ABSOLUTE = 'absolute';
  var MOUSE_OVER = 'mouseover';
  var MOUSE_LEAVE = 'mouseleave';
  var TOAST_ID = 'toast_';
  var MIN_SCREEN_WIDTH = 768;
  var TOAST_REF_ELEMENT = 'e-toast-ref-element';

  var SfToast =
  /** @class */
  function () {
    function SfToast(element, options, dotnetRef) {
      this.progressObj = [];
      this.element = element;
      this.dotNetRef = dotnetRef;
      this.updateContext(options);
      this.element.blazor__instance = this;
    }

    SfToast.prototype.initialize = function (element) {
      this.refElement = sf.base.createElement('div', {
        className: TOAST_REF_ELEMENT
      });
      this.toastContainer = element;
      var parentEle = element.parentElement;
      parentEle.insertBefore(this.refElement, element);
      this.isDevice = sf.base.Browser.isDevice;

      if (this.width === DEFAULT_WIDTH) {
        this.width = this.isDevice && screen.width < MIN_SCREEN_WIDTH ? HUN_PERCENT : DEFAULT_WIDTH;
        this.toastContainer.classList.add(FULL_WIDTH);
      }

      if (this.isDevice && screen.width < MIN_SCREEN_WIDTH) {
        new sf.base.Touch(this.element, {
          swipe: this.swipeHandler.bind(this)
        });
      }

      this.dotNetRef.invokeMethodAsync(CREATED_EVENT, null);
    };

    SfToast.prototype.show = function (options) {
      this.setAnimation(options);
      var target = _typeof(this.target) === STRING ? document.querySelector(this.target) : document.body;
      options.rootElement.style.zIndex = sf.popups.getZindexPartial(options.rootElement) + '';

      if (sf.base.isNullOrUndefined(target)) {
        return;
      }

      if (target.tagName === BODY) {
        this.toastContainer.style.position = FIXED;
      } else {
        this.toastContainer.style.position = ABSOLUTE;
        target.style.position = RELATIVE;
      }

      target.appendChild(this.toastContainer);
      this.appendToast(options.element);
      var id = parseInt(options.element.id.split(TOAST_ID)[1], 10);
      this.progressObj[id] = {
        hideEstimatedTimeOfArrival: null,
        intervalId: null,
        maxHideTime: null,
        element: null,
        timeOutId: null,
        progressEle: null
      };
      this.progressObj[id].element = options.element;

      if (this.extendedTimeout > 0 && this.timeOut > 0) {
        sf.base.EventHandler.add(options.element, MOUSE_OVER, this.toastHoverAction.bind(this, id));
        sf.base.EventHandler.add(options.element, MOUSE_LEAVE, this.delayedToastProgress.bind(this, id));
      }

      if (options.showProgressBar) {
        this.progressObj[id].progressEle = options.element.querySelector('.' + PROGRESS);
      }

      sf.base.EventHandler.add(options.element, KEYDOWN, this.keyDownHandler, this);
    };

    SfToast.prototype.getDomObject = function (value, element) {
      if (element != null) {
        // eslint-disable-next-line
        return window.sfBlazor.getDomObject(value, element);
      } else {
        return null;
      }
    };

    SfToast.prototype.swipeHandler = function (e) {
      var toastEle = sf.base.closest(e.originalEvent.target, '.' + TOAST_PRE + ':not(.' + TOAST_CONTAINER + ')');
      var animation = this.hideAnimation.effect;

      if (!sf.base.isNullOrUndefined(toastEle)) {
        if (e.swipeDirection === RIGHT) {
          this.hideAnimation.effect = 'SlideRightOut';
          this.hide('swipe', toastEle);
        } else if (e.swipeDirection === LEFT) {
          this.hideAnimation.effect = 'SlideLeftOut';
          this.hide('swipe', toastEle);
        }

        this.hideAnimation.effect = animation;
      }
    };

    SfToast.prototype.delayedToastProgress = function (id) {
      var progress = this.progressObj[id];
      var toastEle = progress.element;
      progress.timeOutId = window.setTimeout(this.destroyToast.bind(this, toastEle), this.extendedTimeout);
      progress.maxHideTime = parseFloat(this.extendedTimeout + '');
      progress.hideEstimatedTimeOfArrival = new Date().getTime() + progress.maxHideTime;

      if (!sf.base.isNullOrUndefined(toastEle.querySelector('.' + PROGRESS))) {
        progress.intervalId = setInterval(this.updateProgressBar.bind(this, progress), 10);
      }
    };

    SfToast.prototype.toastHoverAction = function (id) {
      this.dotNetRef.invokeMethodAsync('ClearTimeout', id);
      clearTimeout(this.progressObj[id].timeOutId);
      clearInterval(this.progressObj[id].intervalId);
      this.progressObj[id].hideEstimatedTimeOfArrival = 0;
      var toastEle = this.progressObj[id].element;

      if (!sf.base.isNullOrUndefined(toastEle.querySelector('.' + PROGRESS))) {
        this.progressObj[id].progressEle.style.width = '0%';
      }

      this.dotNetRef.invokeMethodAsync(MOUSEOVER_EVENT, id);
    };

    SfToast.prototype.updateProgressBar = function (progressObj) {
      var percentage = (progressObj.hideEstimatedTimeOfArrival - new Date().getTime()) / progressObj.maxHideTime * 100;
      percentage = this.progressDirection === 'LTR' ? 100 - percentage : percentage;
      progressObj.progressEle.style.width = percentage + '%';
    };

    SfToast.prototype.appendToast = function (toastElement) {
      if (this.newestOnTop && this.toastContainer.childElementCount !== 0) {
        this.toastContainer.insertBefore(toastElement, this.toastContainer.children[0]);
      }

      sf.base.removeClass([toastElement], TOAST_BLAZOR_HIDDEN);
    };

    SfToast.prototype.setAnimation = function (toastObj) {
      var _this = this;

      var proxy = this;
      var showAnimate = this.showAnimation;
      var animate = {
        duration: showAnimate.duration,
        name: showAnimate.effect,
        timingFunction: showAnimate.easing
      };

      animate.begin = function () {
        toastObj.element.style.display = '';
      };

      animate.end = function () {
        if (!sf.base.isNullOrUndefined(document.querySelector('#' + proxy.element.id))) {
          proxy.dotNetRef.invokeMethodAsync(OPEN_EVENT, toastObj.index, _this.getDomObject(ELEMENT, toastObj.element));
        }
      };

      new sf.base.Animation(animate).animate(toastObj.element);
    };

    SfToast.prototype.hide = function (interactionType, element) {
      if (sf.base.isNullOrUndefined(this.toastContainer) || this.toastContainer.childElementCount === 0) {
        return;
      }

      if (_typeof(element) === STRING && element === ALL) {
        for (var i = 0; i < this.toastContainer.childElementCount; i++) {
          this.destroyToast(this.toastContainer.children[i], interactionType);
        }

        return;
      } else if (_typeof(element) === STRING && element !== ALL) {
        var ele = this.toastContainer.querySelector('#toast_' + element);

        if (ele) {
          this.destroyToast(ele, interactionType);
          this.dotNetRef.invokeMethodAsync(DESTROY_TIMER, parseInt(element, 10));
        }
      }

      if (sf.base.isNullOrUndefined(element)) {
        element = this.newestOnTop ? this.toastContainer.lastElementChild : this.toastContainer.firstElementChild;
      }

      this.destroyToast(element, interactionType);
      var id = parseInt(element.id.split('toast_')[1], 10);
      this.dotNetRef.invokeMethodAsync(DESTROY_TIMER, id);
    };

    SfToast.prototype.destroyToast = function (element, interactionType) {
      var id = parseInt(element.id.split('toast_')[1], 10);
      this.dotNetRef.invokeMethodAsync(ON_CLOSE_EVENT, id, interactionType);
    };

    SfToast.prototype.hideAnimationToast = function (element, index) {
      var proxy = this;
      var hideAnimate = this.hideAnimation;
      var animate = {
        duration: hideAnimate.duration,
        name: hideAnimate.effect,
        timingFunction: hideAnimate.easing
      };

      animate.end = function () {
        sf.base.detach(element);
        proxy.dotNetRef.invokeMethodAsync(CLOSE_EVENT, index);
      };

      new sf.base.Animation({}).animate(element, animate);
    };

    SfToast.prototype.destroy = function () {
      while (this.toastContainer.attributes.length > 0) {
        this.toastContainer.removeAttribute(this.toastContainer.attributes[0].name);
      }

      var splitNodes = this.toastContainer.children;

      for (var i = splitNodes.length - 1; i >= 0; i--) {
        sf.base.detach(splitNodes[i]);
      }

      if (!sf.base.isNullOrUndefined(this.refElement) && !sf.base.isNullOrUndefined(this.refElement.parentElement)) {
        this.refElement.parentElement.insertBefore(this.toastContainer, this.refElement);
        sf.base.detach(this.refElement);
        this.refElement = undefined;
      }
    };

    SfToast.prototype.keyDownHandler = function (e) {
      if (e.target.classList.contains(CLOSEBTN) && (e.keyCode === ENTER_KEY || e.keyCode === SPACE_KEY)) {
        var target = e.target;
        var toastEle = sf.base.closest(target, '.' + ROOT);
        this.destroyToast(toastEle, 'key');
      }
    };

    SfToast.prototype.updateContext = function (toastObj) {
      sf.base.extend(this, this, toastObj);
    };

    return SfToast;
  }(); // eslint-disable-next-line


  var Toast = {
    initialize: function initialize(element, options, dotnetRef) {
      if (!sf.base.isNullOrUndefined(element)) {
        new SfToast(element, options, dotnetRef);
        element.blazor__instance.initialize(element);
      }
    },
    show: function show(toastObj) {
      if (!sf.base.isNullOrUndefined(toastObj.rootElement)) {
        toastObj.rootElement.blazor__instance.updateContext(toastObj);
        toastObj.rootElement.blazor__instance.show(toastObj);
      }
    },
    hideAnimationToast: function hideAnimationToast(element, index) {
      if (!sf.base.isNullOrUndefined(element)) {
        element.blazor__instance.hideAnimationToast(element.querySelector('#toast_' + index), index);
      }
    },
    hide: function hide(element, toastElement, toastObj, interactionType) {
      if (!sf.base.isNullOrUndefined(element)) {
        element.blazor__instance.updateContext(toastObj);
        element.blazor__instance.hide(interactionType, toastElement);
      }
    },
    appendToast: function appendToast(element, toastElement) {
      if (!sf.base.isNullOrUndefined(element)) {
        element.blazor__instance.appendToast(toastElement);
      }
    },
    destroy: function destroy(element) {
      if (!sf.base.isNullOrUndefined(element)) {
        element.blazor__instance.destroy();
      }
    }
  };
  return Toast;
}();

/***/ })

/******/ });